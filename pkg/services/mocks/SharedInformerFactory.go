// Code generated by mockery v2.9.4. DO NOT EDIT.

package mocks

import (
	admissionregistration "k8s.io/client-go/informers/admissionregistration"
	apiserverinternal "k8s.io/client-go/informers/apiserverinternal"

	apps "k8s.io/client-go/informers/apps"

	autoscaling "k8s.io/client-go/informers/autoscaling"

	batch "k8s.io/client-go/informers/batch"

	cache "k8s.io/client-go/tools/cache"

	certificates "k8s.io/client-go/informers/certificates"

	coordination "k8s.io/client-go/informers/coordination"

	core "k8s.io/client-go/informers/core"

	discovery "k8s.io/client-go/informers/discovery"

	events "k8s.io/client-go/informers/events"

	extensions "k8s.io/client-go/informers/extensions"

	flowcontrol "k8s.io/client-go/informers/flowcontrol"

	informers "k8s.io/client-go/informers"

	internalinterfaces "k8s.io/client-go/informers/internalinterfaces"

	mock "github.com/stretchr/testify/mock"

	networking "k8s.io/client-go/informers/networking"

	node "k8s.io/client-go/informers/node"

	policy "k8s.io/client-go/informers/policy"

	rbac "k8s.io/client-go/informers/rbac"

	reflect "reflect"

	runtime "k8s.io/apimachinery/pkg/runtime"

	scheduling "k8s.io/client-go/informers/scheduling"

	schema "k8s.io/apimachinery/pkg/runtime/schema"

	storage "k8s.io/client-go/informers/storage"
)

// SharedInformerFactory is an autogenerated mock type for the SharedInformerFactory type
type SharedInformerFactory struct {
	mock.Mock
}

// Admissionregistration provides a mock function with given fields:
func (_m *SharedInformerFactory) Admissionregistration() admissionregistration.Interface {
	ret := _m.Called()

	var r0 admissionregistration.Interface
	if rf, ok := ret.Get(0).(func() admissionregistration.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(admissionregistration.Interface)
		}
	}

	return r0
}

// Apps provides a mock function with given fields:
func (_m *SharedInformerFactory) Apps() apps.Interface {
	ret := _m.Called()

	var r0 apps.Interface
	if rf, ok := ret.Get(0).(func() apps.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(apps.Interface)
		}
	}

	return r0
}

// Autoscaling provides a mock function with given fields:
func (_m *SharedInformerFactory) Autoscaling() autoscaling.Interface {
	ret := _m.Called()

	var r0 autoscaling.Interface
	if rf, ok := ret.Get(0).(func() autoscaling.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(autoscaling.Interface)
		}
	}

	return r0
}

// Batch provides a mock function with given fields:
func (_m *SharedInformerFactory) Batch() batch.Interface {
	ret := _m.Called()

	var r0 batch.Interface
	if rf, ok := ret.Get(0).(func() batch.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(batch.Interface)
		}
	}

	return r0
}

// Certificates provides a mock function with given fields:
func (_m *SharedInformerFactory) Certificates() certificates.Interface {
	ret := _m.Called()

	var r0 certificates.Interface
	if rf, ok := ret.Get(0).(func() certificates.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(certificates.Interface)
		}
	}

	return r0
}

// Coordination provides a mock function with given fields:
func (_m *SharedInformerFactory) Coordination() coordination.Interface {
	ret := _m.Called()

	var r0 coordination.Interface
	if rf, ok := ret.Get(0).(func() coordination.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coordination.Interface)
		}
	}

	return r0
}

// Core provides a mock function with given fields:
func (_m *SharedInformerFactory) Core() core.Interface {
	ret := _m.Called()

	var r0 core.Interface
	if rf, ok := ret.Get(0).(func() core.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(core.Interface)
		}
	}

	return r0
}

// Discovery provides a mock function with given fields:
func (_m *SharedInformerFactory) Discovery() discovery.Interface {
	ret := _m.Called()

	var r0 discovery.Interface
	if rf, ok := ret.Get(0).(func() discovery.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(discovery.Interface)
		}
	}

	return r0
}

// Events provides a mock function with given fields:
func (_m *SharedInformerFactory) Events() events.Interface {
	ret := _m.Called()

	var r0 events.Interface
	if rf, ok := ret.Get(0).(func() events.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(events.Interface)
		}
	}

	return r0
}

// Extensions provides a mock function with given fields:
func (_m *SharedInformerFactory) Extensions() extensions.Interface {
	ret := _m.Called()

	var r0 extensions.Interface
	if rf, ok := ret.Get(0).(func() extensions.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(extensions.Interface)
		}
	}

	return r0
}

// Flowcontrol provides a mock function with given fields:
func (_m *SharedInformerFactory) Flowcontrol() flowcontrol.Interface {
	ret := _m.Called()

	var r0 flowcontrol.Interface
	if rf, ok := ret.Get(0).(func() flowcontrol.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(flowcontrol.Interface)
		}
	}

	return r0
}

// ForResource provides a mock function with given fields: resource
func (_m *SharedInformerFactory) ForResource(resource schema.GroupVersionResource) (informers.GenericInformer, error) {
	ret := _m.Called(resource)

	var r0 informers.GenericInformer
	if rf, ok := ret.Get(0).(func(schema.GroupVersionResource) informers.GenericInformer); ok {
		r0 = rf(resource)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(informers.GenericInformer)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(schema.GroupVersionResource) error); ok {
		r1 = rf(resource)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InformerFor provides a mock function with given fields: obj, newFunc
func (_m *SharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer {
	ret := _m.Called(obj, newFunc)

	var r0 cache.SharedIndexInformer
	if rf, ok := ret.Get(0).(func(runtime.Object, internalinterfaces.NewInformerFunc) cache.SharedIndexInformer); ok {
		r0 = rf(obj, newFunc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cache.SharedIndexInformer)
		}
	}

	return r0
}

// Internal provides a mock function with given fields:
func (_m *SharedInformerFactory) Internal() apiserverinternal.Interface {
	ret := _m.Called()

	var r0 apiserverinternal.Interface
	if rf, ok := ret.Get(0).(func() apiserverinternal.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(apiserverinternal.Interface)
		}
	}

	return r0
}

// Networking provides a mock function with given fields:
func (_m *SharedInformerFactory) Networking() networking.Interface {
	ret := _m.Called()

	var r0 networking.Interface
	if rf, ok := ret.Get(0).(func() networking.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(networking.Interface)
		}
	}

	return r0
}

// Node provides a mock function with given fields:
func (_m *SharedInformerFactory) Node() node.Interface {
	ret := _m.Called()

	var r0 node.Interface
	if rf, ok := ret.Get(0).(func() node.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(node.Interface)
		}
	}

	return r0
}

// Policy provides a mock function with given fields:
func (_m *SharedInformerFactory) Policy() policy.Interface {
	ret := _m.Called()

	var r0 policy.Interface
	if rf, ok := ret.Get(0).(func() policy.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(policy.Interface)
		}
	}

	return r0
}

// Rbac provides a mock function with given fields:
func (_m *SharedInformerFactory) Rbac() rbac.Interface {
	ret := _m.Called()

	var r0 rbac.Interface
	if rf, ok := ret.Get(0).(func() rbac.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(rbac.Interface)
		}
	}

	return r0
}

// Scheduling provides a mock function with given fields:
func (_m *SharedInformerFactory) Scheduling() scheduling.Interface {
	ret := _m.Called()

	var r0 scheduling.Interface
	if rf, ok := ret.Get(0).(func() scheduling.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(scheduling.Interface)
		}
	}

	return r0
}

// Start provides a mock function with given fields: stopCh
func (_m *SharedInformerFactory) Start(stopCh <-chan struct{}) {
	_m.Called(stopCh)
}

// Storage provides a mock function with given fields:
func (_m *SharedInformerFactory) Storage() storage.Interface {
	ret := _m.Called()

	var r0 storage.Interface
	if rf, ok := ret.Get(0).(func() storage.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.Interface)
		}
	}

	return r0
}

// WaitForCacheSync provides a mock function with given fields: stopCh
func (_m *SharedInformerFactory) WaitForCacheSync(stopCh <-chan struct{}) map[reflect.Type]bool {
	ret := _m.Called(stopCh)

	var r0 map[reflect.Type]bool
	if rf, ok := ret.Get(0).(func(<-chan struct{}) map[reflect.Type]bool); ok {
		r0 = rf(stopCh)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[reflect.Type]bool)
		}
	}

	return r0
}
